#include <REG51F380.H>

ARRAY EQU 2000H
	
							;ATRIBUICAO DE VALORES AOS ESTADOS
S_READY		EQU 0
S_OP1		EQU 1
S_SELECT	EQU 2
S_OP2       EQU 3
S_PROCESS   EQU 4  

K_SET       EQU P0.6			
K_LOAD      EQU P0.7                  

DSEG AT 30H						;DATA SEGMENT AT 30H->GUARDA A PARTIR DE 30H NA MEMORIA DE DADOS

STATE: 		  DS 1 				;STATE É O ESTADO ATUAL -> DS 1 == OPERACAO OCUPA 1 BYTE DE MEMORIA
NEXT_STATE:   DS 1 				;PRÓXIMO ESTADO DESEJADO
VAR_OP1:      DS 1 				;OPERADOR 1
VAR_OP2:      DS 1 				;OPERADOR 2
VAR_OPERACAO: DS 1 				;OPERAÇÃO SELECIONADA
VAR_RESULTADO:DS 1 				;RESULTADO 

								;R2 INDICE DO ARRAY DE OPERAÇÕES
              
CSEG AT 0           			;RESPOSTA AO RESET
	SJMP INIT
CSEG AT 30H

INIT:
	MOV PCA0MD,#0
    MOV XBR1,#40H	
								;INICIALIZAÇÃO DE VARIÁVEIS
    MOV VAR_OP1,#0
	MOV VAR_OP2,#0
    MOV VAR_OPERACAO,#0
	MOV VAR_RESULTADO,#0
    MOV STATE,#S_READY
    MOV NEXT_STATE,#S_READY
	
    SJMP MAIN

MAIN:
CTR_FSM:						;FUNÇÃO PRINCIPAL PARA CONTROLO DA FSM
	MOV STATE,#S_READY
								;SWITCH CASE DA FSM				
CTR_L2:
    JB K_LOAD,CTR_L2			;ESPERAR POR K_LOAD

CTR_L3:             
	JNB K_LOAD,CTR_L3
    MOV STATE,NEXT_STATE		;ATUALIZAR ESTADO

								;SWITCH CASE ONDE SALTA PARA ESTADOS DA FSM
JT_FSM:
	MOV A,STATE
	RL A						;INSTRUCAO OCUPA 2 BYTES RL->MULTIPLICA POR 2 
    MOV DPTR,#STATE_JUMP
    JMP @A+DPTR

STATE_JUMP:
	AJMP SR_SREADY      		;SALTAR CODIFICAÇÃO DO S_READY
    AJMP SR_SOP1				;SALTAR CODIFICAÇÃO DO S_OP1
	AJMP SR_SELECT      		;SALTAR CODIFICAÇÃO DO SR_SELECT
    AJMP SR_SOP2				;SALTAR CODIFICAÇÃO DO S_OP2
    AJMP SR_SPROCESS			;SALTAR CODIFICAÇÃO DO S_PROCESS
    AJMP ERROR          		;ERRO NO CONTROLO DA FSM

							
SR_SREADY:						;CODIFICAR S_READY
	MOV P2,#0AFH				;'r' NO DISPLAY
	MOV VAR_OPERACAO,#0			;VOLTAR A 0 NO ARRAY DE OPERACOES
	JNB K_SET,SR_AUTO_OP1		;SE K_SET FOR PRESSIONADO SALTA PARA O AUTO_OP1->VAI LOGO PARA S_SELECT
    MOV NEXT_STATE,#S_OP1		;O NEXT_STATE TOMA O VALOR DE S_OP1 PARA NA TABELA DE SALTOS IR LOGO PARA OP1
	JB K_LOAD,SR_SREADY			;SE O K_LOAD NAO FOR PRESSIONADO ELE FICA SEMPRE NO MESMO CICLO
    AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

SR_AUTO_OP1:					;FUNCAO QUE APROVEITA O VALOR OP1 E PASSA LOGO PARA S_SELECT
	MOV VAR_OP1,P1				;APROVEITA O VALOR NO P1 E PASSA PARA A VARIAVEL
	MOV NEXT_STATE,#S_SELECT	;O NEXT_STATE TOMA O VALOR DE S_SELECT->2 PARA UTILIZAR NA TABELA DE SALTOS
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

;CODIFICAR S_OP1
SR_SOP1:						;FUNCAO OP1 
	MOV P2,#0F9H				;'1' NO DISPLAY
    MOV VAR_OP1,P4				;VAR_OP1 TOMA O VALOR DE P4
	MOV NEXT_STATE,#S_SELECT	;O NEXT_STATE TOMA O VALOR DE S_SELECT->2 PARA UTILIZAR NA TABELA DE SALTOS
    AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

;CODIFICAR S_SELECT
SR_SELECT:						;FUNCAO S_SELECT
	;MOV P2,#77H 				;'_.' NO DISPLAY
	;JB K_LOAD,SR_SELECT
	MOV A,VAR_OPERACAO			;CARREGA NO ACC A CONSTANTE QUE ESTA EM VAR_OPERACAO 
	ANL A,#7					;AND LOGIC COM O VALOR 7->ULTIMO DO ARRAY DE OPERACOES SE A==7->O VALOR=1
	MOV DPTR,#ARRAY				;IMPLEMENTACAO DA TABELA DE SALTOS DO ARRAY
	MOVC A,@A+DPTR				
	MOV P2,A					;UPDATE DISPLAY 
	
SR_CLICK:						;FUNCAO DETETAR CLICK DOS 2 BOTOES
	JNB K_SET,SR_INC_ARRAY		;SE K_SET PRESSIONADO->SALTA PARA A SR_INC_ARRAY
	JNB K_LOAD,SR_CLICK_LOAD	;SE K_LOAD PRESSIONADO->SALTA PARA A SR_CLICK_LOAD
	SJMP SR_CLICK				;SE NENHUM DOS BOTOES FOR PRESSIONADO FICA EM CICLO INFINITO
	
SR_CLICK_LOAD:					;FUNCAO CLICK LOAD
	MOV NEXT_STATE,#S_OP2		;UPDATE DO NEXT_STATE TOMA O VALOR DE S_OP2==3 PARA SER UTILIZADO NA TABELA DE SALTOS
	MOV A,VAR_OPERACAO			;PASSA PARA O ACC A CONSTANTE DE VAR_OPERACAO
	CLR C						;CLEAR AO CARRY PARA FAZER A SUBB
	SUBB A,#4					;SE FOR MAIOR QUE 0->C=0 UTILIZAMOS O VALOR 4 POIS SAO AS PRIMEIRAS 4 OP'S QUE NECESSITAM DE 2 OPERANDOS
	CPL C						;COMPLEMENTO PARA 2 DO CARRY->INVERSO DO CARRY 				 
	CLR A						;CLEAR AO ACC
    ADDC A,NEXT_STATE			;SE A=1->NEXT_STATE=SR_SPROCESS/A=0->NEXT_STATE=SR_SOP2
	MOV NEXT_STATE,A			;NEXT_STATE TOMA O VALOR DE ACC
	MOV VAR_OP1,P4				;CARREGA O VALOR DE P4 PARA A VARIAVEL OP1
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE
	
SR_INC_ARRAY:					;FUNCAO INCREMENTAR ARRAY DE OPERACOES
	JNB K_SET,$					;DETETAR SE O K_SET JA NAO ESTA PRESSIONADO
	INC VAR_OPERACAO			;INCREMENTAR A VARIAVEL DAS OPERACOES
	SJMP SR_SELECT				;SALTA PARA A FUNCAO SELECT 

;CODIFICAR S_OP2
SR_SOP2:						;FUNCAO S_OP2
	MOV P2,#0A4H				;'2' NO DISPLAY
	MOV VAR_OP2,P4				;CARREGA O P4 PARA A VAR_OP2
    MOV NEXT_STATE,#S_PROCESS	;UPDATE DO NEXT_STATE TOMA O VALOR DE S_PROCESS==4 PARA SER UTILIZADO NA TABELA DE SALTOS
	JB K_LOAD,SR_SOP2			;SE O K_LOAD NAO FOR PRESSIONADO FICA EM CICLO INFINITO NESTA SUB ROTINA
    AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

;CODIFICAR S_PROCESS
SR_SPROCESS:					;FUNCAO S_PROCESS
	MOV A,VAR_OPERACAO			;A TOMA O VALOR DA VAR_OPERACAO
	MOV DPTR,#SELECT			;APONTA PARA A TABELA
	RL A						;RL->MULTIPLICAR POR 2->OPERACAO VAI DE 2 EM 2 BYTES
	JMP @A+DPTR					;SALTA PARA O VALOR RESPETIVO NA TABELA DE SALTOS

SELECT:
	AJMP SR_ADD					;0
	AJMP SR_SUBB				;1
	AJMP SR_AND					;2
	AJMP SR_OR					;3	
	AJMP SR_XOR					;4
	AJMP SR_NOT					;5
	AJMP SR_RL					;6
	AJMP SR_RR					;7

								;SUB ROTINAS DAS OPERACOES
								
SR_AND:							;OPERACAO AND
	MOV A,VAR_OP1				;ACC TOMA O VALOR DE OPERADOR 1
	ANL A,VAR_OP2				;AND LOGICO ENTRE O ACC E A VAR_OP2
	MOV VAR_RESULTADO,A			;VAR_RESULTADO TOMA O VALOR DE ACC
	MOV P1,VAR_RESULTADO		;RESULTADO FICA ARMAZENADO EM P1
	MOV NEXT_STATE,S_READY		;UPDATE DO NEXT_STATE TOMA O VALOR DE S_READY==0 PARA SER UTILIZADO NA TABELA DE SALTOS 
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE
	
SR_OR:							;OPERACAO OR
	MOV A,VAR_OP1				;ACC TOMA O VALOR DE OP 1
	ORL A,VAR_OP2				;OR LOGICO ENTRE O ACC E O OP_2
	MOV VAR_RESULTADO,A			;VAR RESULTADO TOMA O VALOR DE ACC
	MOV P1,VAR_RESULTADO		;VAR RESULTADO FICA ARMAZENADO EM P1
	MOV NEXT_STATE,S_READY		;UPDATE DO NEXT_STATE TOMA O VALOR DE S_READY==0 PARA SER UTILIZADO NA TABELA DE SALTOS 
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

SR_NOT:							;OPERACAO NOT
	MOV A,VAR_OP1				;ACC TOMA O VALOR DE OP1
	CPL A						;COMPLEMENTO PARA 2 DO ACC == NEGAR O ACC->NOT
	MOV VAR_RESULTADO,A			;VAR RESULTADO TOMA O VALOR DO ACC
	MOV P1,VAR_RESULTADO		;VAR RESULTADO FICA ARMAZENADO EM P1
	MOV NEXT_STATE,S_READY		;UPDATE DO NEXT_STATE TOMA O VALOR DE S_READY==0 PARA SER UTILIZADO NA TABELA DE SALTOS 
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE
	
SR_XOR:							;OPERACAO XOR
	MOV A,VAR_OP1				;ACC TOMA O VALOR DE OP1
	XRL A,VAR_OP2				;XOR LOGICO ENTRE A E VAR_OP2
	MOV VAR_RESULTADO,A			;VAR_RESULTADO TOMA O VALOR DE ACC
	MOV P1,VAR_RESULTADO		;VAR_RESULTADO FICA ARMAZENADO EM P1
	MOV NEXT_STATE,S_READY		;UPDATE DO NEXT_STATE TOMA O VALOR DE S_READY==0 PARA SER UTILIZADO NA TABELA DE SALTOS 
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

SR_ADD:							;OPERACAO ADD
	MOV A,VAR_OP1				;ACC TOMA O VALOR DE OP1
	ADD A,VAR_OP2				;ADD VAR_OP2 AO ACC
	MOV VAR_RESULTADO,A			;VAR_RESULTADO TOMA O VALOR DE ACC
	MOV P1,VAR_RESULTADO		;VAR_RESULTADO FICA ARMAZENADO EM P1
	MOV NEXT_STATE,S_READY		;UPDATE DO NEXT_STATE TOMA O VALOR DE S_READY==0 PARA SER UTILIZADO NA TABELA DE SALTOS 
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

SR_SUBB:						;OPERACAO SUBB
	MOV A,VAR_OP1				;ACC TOMA O VALOR DE OP1
	CLR C						;CLEAR CARRY PARA FAZER A SUBB
	SUBB A,VAR_OP2				;SUBB VAR_OP2 AO ACC
	MOV VAR_RESULTADO,A			;VAR_RESULTADO TOMA O VALOR DE ACC
	MOV P1,VAR_RESULTADO		;VAR_RESULTADO FICA ARMAZENADO EM P1
	MOV NEXT_STATE,S_READY		;UPDATE DO NEXT_STATE TOMA O VALOR DE S_READY==0 PARA SER UTILIZADO NA TABELA DE SALTOS 
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

SR_RL:							;OPERACAO ROTATE LEFT
	MOV A,VAR_OP1				;ACC TOMA O VALOR DE OP1
	RL A						;ROTATE LEFT DO ACC
	MOV VAR_RESULTADO,A			;VAR_RESULTADO TOMA O VALOR DE ACC
	MOV P1,VAR_RESULTADO		;VAR_RESULTADO FICA ARMAZENADO EM P1
	MOV NEXT_STATE,S_READY		;UPDATE DO NEXT_STATE TOMA O VALOR DE S_READY==0 PARA SER UTILIZADO NA TABELA DE SALTOS 
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

SR_RR:							;OPERACAO ROTATE RIGHT
	MOV A,VAR_OP1				;ACC TOMA O VALOR DE OP1
	RR A						;ROTATE RIGHT DO ACC
	MOV VAR_RESULTADO,A 		;VAR_RESULTADO TOMA O VALOR DE ACC
	MOV P1,VAR_RESULTADO		;VAR_RESULTADO ARMAZENADO EM P1
	MOV NEXT_STATE,S_READY		;UPDATE DO NEXT_STATE TOMA O VALOR DE S_READY==0 PARA SER UTILIZADO NA TABELA DE SALTOS 
	AJMP CTR_FSM				;SALTA PARA O CONTROL FSM->STATE MACHINE

ERROR:							;ESTADO ERRO
    MOV P2,#0FFH				;DISPLAY DESLIGADO
    CLR P2.7					;LIMPA O BIT 7 DO P2
    JMP $		

CSEG AT ARRAY
	DB 8CH,92H,88H,0C0H,89H,0ABH,0C7H,08H

END