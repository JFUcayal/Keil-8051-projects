#include <REG51F380.H>

DIGIT_ARRAY EQU 2000H

KEY_TABLE		EQU 80H
SECRET_TABLE	EQU 88H

OUTPUT	EQU P1.0		
BUZZER  EQU P1.7
K_SET	EQU P0.6
K_LOAD	EQU P0.7

S_RECOVER  EQU 0
S_LOCKED   EQU 1
S_DECRYPT  EQU 2
S_FAIL	   EQU 3
S_OPEN	   EQU 4
S_ENCRYPT  EQU 5
S_BLOCKED  EQU 6

MASK_SIZE  EQU 3				;KEY_SIZE-1
MAX_TRIES  EQU 5

BSEG AT 0H
NOT_EQUAL:				DBIT 1
FLAG_TIMEOUT:			DBIT 1
FLAG_VALID:				DBIT 1
FLAG_EXAUSTED:			DBIT 1
FLAG_K_LOAD:			DBIT 1
FLAG_ENCRYPT:			DBIT 1
FLAG_FAIL:				DBIT 1
FLAG_CHAR_B:			DBIT 1
FLAG_COUNTER_OPEN:		DBIT 1
FLAG_COUNTER_FAIL:		DBIT 1
FLAG_COUNTER_BLOCKED:	DBIT 1
FLAG_10S:				DBIT 1
FLAG_15S:				DBIT 1
FLAG_20S:				DBIT 1
FLAG_30S:				DBIT 1
FLAG_40S:				DBIT 1
FLAG_50S:				DBIT 1

DSEG AT 30H	
STATE:				DS 1
NEXT_STATE: 		DS 1
N_SELECTED:			DS 1
ATTEMPTS:			DS 1
TIME_INDEX:			DS 1
KEY_SIZE:			DS 1
KEY_INDEX:			DS 1
COUNTER:			DS 1
STATE_SIZE:			DS 1
LOCKED_SIZE:		DS 1
DECRYPT_SIZE:		DS 1
FAIL_SIZE:			DS 1
OPEN_SIZE:			DS 1
ENCRYPT_SIZE:		DS 1
BLOCKED_SIZE:		DS 1
RECOVER_SIZE:		DS 1
ATTEMPT_SIZE:		DS 1
ATTEMPT_NUM_SIZE:	DS 1
ATTEMPT_COUNTER:	DS 1
VAR_1:				DS 1
VAR_2:				DS 1
VAR_3:				DS 1
COUNTER_ISR_OPEN:	DS 1
COUNTER_ISR_FAIL:	DS 1
COUNTER_ISR_BLOCKED:DS 1
COUNTER_BLINK:		DS 1

CSEG AT 3H
	JMP INTERRUPT_K_LOAD
CSEG AT 0BH
	JMP ISR_TMR0
CSEG AT 0
	SJMP INIT
CSEG AT 30H
	
INIT:
	MOV FLSCL, #90H		
	MOV CLKSEL, #3
	MOV PCA0MD,#0
	MOV XBR0,#1
	MOV XBR1,#40H					
	
	MOV SP,#(255-32)
	
	MOV IE,#82H					;ENABLE INTERRUPT 
	MOV IT01CF,#7H				;INTERRUPT P0.7 ATIVO
	
	MOV KEY_SIZE,#4				;define o tamanho da chave
	MOV KEY_INDEX,KEY_SIZE
	
	MOV N_SELECTED,#0				
	MOV ATTEMPTS,#0
	MOV TIME_INDEX,#0
	MOV COUNTER,#0
	
	CLR FLAG_K_LOAD
	CLR FLAG_ENCRYPT
	CLR NOT_EQUAL
	CLR FLAG_TIMEOUT
	CLR FLAG_VALID
	CLR FLAG_EXAUSTED
	CLR FLAG_FAIL
	CLR FLAG_CHAR_B
	CLR FLAG_10S
	CLR FLAG_15S
	CLR FLAG_20S
	CLR FLAG_30S
	CLR FLAG_40S	
	CLR FLAG_50S
	CLR FLAG_COUNTER_OPEN
	CLR	FLAG_COUNTER_FAIL
	CLR	FLAG_COUNTER_BLOCKED
	
	MOV R1,#0
	MOV R2,#0
	MOV R3,#0
	MOV R4,#0
	MOV R5,#0
	MOV R6,#0
	MOV R7,#0

	MOV STATE_SIZE,#6
	MOV LOCKED_SIZE,#6
	MOV DECRYPT_SIZE,#7
	MOV FAIL_SIZE,#4
	MOV OPEN_SIZE,#4
	MOV ENCRYPT_SIZE,#7
	MOV BLOCKED_SIZE,#7
	MOV RECOVER_SIZE,#7
	MOV ATTEMPT_SIZE,#10
	MOV ATTEMPT_NUM_SIZE,#5
	MOV ATTEMPT_COUNTER,#0

	MOV R0,#SECRET_TABLE
	MOV @R0,#0
	MOV R0,#KEY_TABLE
	MOV @R0,#0

	MOV STATE,#S_RECOVER
	MOV NEXT_STATE,#S_RECOVER

	;CONFIG UART0
	MOV TMOD,#20H
	MOV TH1,#30H			;115200bps@48MHz
	ORL CKCON,#8
	SETB TR1
	
	ACALL SR_CONFIG_TMR0
	
	CLR TI0
	SETB EA
	SETB ET0				;INTERRUPT->TIMER 0

	SJMP MAIN	
	
MAIN:
	CLR P2.7
;----------------------------------------------------------------------------------------------------
CTR_FSM:
	MOV STATE,#S_LOCKED
	
CTR_L2:
	JB K_LOAD,CTR_L2
	
CTR_L3:
	JNB K_LOAD,CTR_L3
	MOV STATE,NEXT_STATE
	
JT_FSM:
	MOV A,STATE
	RL A
	MOV DPTR,#STATE_JUMP
	JMP @A+DPTR
	
STATE_JUMP:
	AJMP STATE_RECOVER
	AJMP STATE_LOCKED
	AJMP STATE_DECRYPT  
	AJMP STATE_FAIL	   
	AJMP STATE_OPEN  
	AJMP STATE_ENCRYPT  
	AJMP STATE_BLOCKED
;------------------------------------------------------
STATE_RECOVER:
	;INFORMAÇÃO ENVIADA PARA O TERMINAL
	SETB  TR1					
	ACALL SR_PRINT_STATE
	ACALL SR_PRINT_RECOVER
	ACALL SR_NEW_LINE
	ACALL SR_PRINT_ATTEMPT
	ACALL SR_PRINT_ATTEMPT_NUM
	ACALL SR_NEW_LINE
	CLR TR1	
	
SR_RECOVER_LOOP:
	MOV DPTR,#SECRET_KEY		;COLOCAR A CHAVE SECRETA(ARRAY) PARA O ESPAÇO DE MEMORIA ALOCADO PARA A SECRET TABLE
	MOV R0,#SECRET_TABLE
	MOV A,N_SELECTED
	MOVC A,@A+DPTR
	MOV N_SELECTED,A
	INC N_SELECTED				;ENCRYPT-> +1
	ACALL SR_INSERT_KEY			;INSERIR A CHAVE POR CADA POSIÇÃO NA SECRET TABLE
	MOV A,KEY_SIZE
	CLR C
	SUBB A,N_SELECTED
	JNZ SR_RECOVER_LOOP			;ENQUANTO NAO CHEGAR AO FIM DA TRANSIÇAO DAS CHAVES FICA EM LOOP PARA INSERIR CADA POSICAO
	
	MOV NEXT_STATE,#S_LOCKED
	AJMP CTR_L3
;------------------------------------------------------
STATE_LOCKED:
	MOV P2,#0C7H	
	SETB OUTPUT					;TENSAO BLOQUEIO NA SAIDA->P1.0	
	
	;INFORMAÇÃO ENVIADA PARA O TERMINAL
	SETB  TR1					;ATIVAÇÃO DE TRANSMISSAO DE DADOS
	ACALL SR_PRINT_STATE
	ACALL SR_PRINT_LOCKED
	ACALL SR_NEW_LINE
	ACALL SR_PRINT_ATTEMPT
	ACALL SR_PRINT_ATTEMPT_NUM
	ACALL SR_NEW_LINE
	CLR TR1						;PARAR A TRANSMISSAO DE DADOS
	
	MOV COUNTER,#0				;RESET AO COUNTER(15s)
	CLR FLAG_K_LOAD				;RESET FLAG
	
	MOV NEXT_STATE,#S_DECRYPT
	AJMP CTR_FSM	
;------------------------------------------------------
STATE_DECRYPT: 
	
	;INFORMAÇÃO ENVIADA PARA O TERMINAL
	SETB  TR1					;ATIVAÇÃO DE TRANSMISSAO DE DADOS
	ACALL SR_PRINT_STATE
	ACALL SR_PRINT_DECRYPT
	ACALL SR_NEW_LINE
	ACALL SR_PRINT_ATTEMPT
	ACALL SR_PRINT_ATTEMPT_NUM
	ACALL SR_NEW_LINE
	CLR TR1						;PARAR A TRANSMISSAO DE DADOS
	
SR_DECRYPT_RESET:
	MOV R7,#0					;RESET AO ARRAY	DISPLAY
	
SR_DISPLAY_NUMS:				;DISPLAY O NUMERO ATUAL DO ARRAY
	JNB K_LOAD,$
	MOV DPTR,#DIGIT_ARRAY
	MOV A,R7
	MOVC A,@A+DPTR
	MOV P2,A
	
SR_CLICK:
	JNB K_SET,SR_ARRAY_INC		;INCREMENTA O ARRAY DE NUMEROS DO DISPLAY
	JNB K_LOAD,SR_SELECT		;SELECIONA O NUMERO QUE SE ENCONTRA NO DISPLAY
	SJMP SR_CLICK
	
SR_ARRAY_INC:
	JNB K_SET,$	
	INC R7
	CJNE R7,#16,SR_DISPLAY_NUMS
	
SR_RESET_ARRAY:					;QUANDO CHEGA AO F(16) VOLTA À POSICAO INICIAL   
	MOV R7,#0
	JMP SR_DISPLAY_NUMS
	
;INSERT	 KEY
SR_SELECT:						;INSERIR CADA NUMERO ESCOLHIDO NA KEY_TABLE
	MOV R0,#KEY_TABLE
	MOV A,@R0
	ANL A,#MASK_SIZE
	MOV @R0,A
	MOV N_SELECTED,R7
	ACALL SR_INSERT_KEY
	DJNZ KEY_INDEX,SR_DECRYPT_RESET
	
	JB FLAG_ENCRYPT,SR_ENCRYPT	;Se já passou pelo state de encrypt a flag fica a 1 e salta para SR_ENCRYPT
	
;DECRYPT PASS	
;COMPARE KEYS
	ACALL SR_COMP_KEYS
	MOV KEY_INDEX,KEY_SIZE		;reset ao valor de index de selecao da chave
	
SR_RESET_KEY:					;RESET DA CHAVE DO UTILIZADOR->chave é limpa da memoria 
	MOV R0,#KEY_TABLE	
SR_RESET_POS:	
	MOV @R0,#0
	INC R0
	DJNZ KEY_INDEX,SR_RESET_POS	;limpa a memoria ate ao valor de KEY_INDEX(=KEY_SIZE)
	
	MOV KEY_INDEX,KEY_SIZE		;reset ao valor de index de selecao da chave
	
;-----------
;START TIMER
	SETB TR0
	
	JB NOT_EQUAL,SR_INVALID
	JNB NOT_EQUAL,SR_VALID
	
SR_ENCRYPT:
	MOV KEY_INDEX,KEY_SIZE		;reset ao valor de index de selecao da chave
	CLR FLAG_ENCRYPT			;dps de definir a nova pass -> flag limpa
	JMP SR_FSM_LOCKED			;STATE_ENCRYPT
	
SR_VALID:
	MOV NEXT_STATE,#S_OPEN
	AJMP CTR_FSM
SR_INVALID:
	MOV NEXT_STATE,#S_FAIL
	AJMP CTR_FSM
;------------------------------------------------------
STATE_FAIL:
	MOV P2,#8EH					;'F' no display
	CLR FLAG_VALID
	SETB FLAG_FAIL
	CLR FLAG_COUNTER_OPEN
	CLR FLAG_COUNTER_BLOCKED
	INC ATTEMPT_COUNTER	
	
	;INFORMAÇÃO ENVIADA PARA O TERMINAL
	SETB  TR1					
	ACALL SR_PRINT_STATE
	ACALL SR_PRINT_FAIL
	ACALL SR_NEW_LINE
	ACALL SR_PRINT_ATTEMPT
	ACALL SR_PRINT_ATTEMPT_NUM
	ACALL SR_NEW_LINE
	CLR TR1	 
	
	
/*	
SR_10S:
	JNB FLAG_10S,$
	JMP SR_FAIL
SR_20S:
	JNB FLAG_20S,$
	JMP SR_FAIL
SR_30S:
	JNB FLAG_30S,$
	JMP SR_FAIL
SR_40S:
	JNB FLAG_40S,$
	JMP SR_FAIL	
SR_50S:
	JNB FLAG_50S,$
*/	
	
SR_FAIL:	 
	INC ATTEMPTS				;max tentativas->5
	CLR C
	MOV A,#MAX_TRIES			;definido na linha 21
	SUBB A,ATTEMPTS
	JZ SR_EXAUSTED				;Se chegar ao max de tentativas->EXAUSTED->BLOCKED
	CLR A
	
	
SR_NOT_EXAUSTED:
	MOV NEXT_STATE,#S_DECRYPT
	CLR FLAG_EXAUSTED
	AJMP CTR_L3					;nao queremos controlo de k_load->automatico
	
SR_EXAUSTED:
	SETB FLAG_EXAUSTED
	MOV NEXT_STATE,#S_BLOCKED
	AJMP CTR_L3					
;------------------------------------------------------
STATE_OPEN:
	SETB EX0
	SETB FLAG_VALID

	MOV ATTEMPTS,#0				;Quando o cofre abrir as tentativas voltam a 0
	MOV ATTEMPT_COUNTER,#0		;RESET das tentativas(UART)
	MOV TIME_INDEX,#0			;A rotina de espera do fail volta a 10s
	
	MOV P2,#40H					;'0.' no display
	CLR OUTPUT					;desliga a tensao de bloqueio
	SETB FLAG_COUNTER_OPEN
	CLR FLAG_COUNTER_FAIL
	CLR FLAG_COUNTER_BLOCKED
	
	;INFORMAÇÃO ENVIADA PARA O TERMINAL
	SETB  TR1					
	ACALL SR_PRINT_STATE
	ACALL SR_PRINT_OPEN
	ACALL SR_NEW_LINE
	ACALL SR_PRINT_ATTEMPT
	ACALL SR_PRINT_ATTEMPT_NUM
	ACALL SR_NEW_LINE
	CLR TR1	

;AVALIAR CONDIÇÃO DOS 15s + K_LOAD
	JNB FLAG_K_LOAD,$
				
SR_FLAG_TIME:
	CLR FLAG_K_LOAD
	JB FLAG_TIMEOUT,SR_LOAD_AND_TIME
	
SR_LOAD_LOCK:
	MOV NEXT_STATE,#S_LOCKED
	AJMP CTR_L3
SR_LOAD_AND_TIME:
	MOV NEXT_STATE,#S_ENCRYPT
	AJMP CTR_L3
;------------------------------------------------------
STATE_ENCRYPT:
	MOV P2,#86H					;'E' no display
	
	;INFORMAÇÃO ENVIADA PARA O TERMINAL
	SETB  TR1					
	ACALL SR_PRINT_STATE
	ACALL SR_PRINT_ENCRYPT
	ACALL SR_NEW_LINE
	ACALL SR_PRINT_ATTEMPT
	ACALL SR_PRINT_ATTEMPT_NUM
	ACALL SR_NEW_LINE
	CLR TR1	
	
	MOV KEY_INDEX,KEY_SIZE		;reset ao valor de index de selecao da chave
	SETB FLAG_ENCRYPT					
			
SR_FSM_ENCRYPT:					;DEFINIR NOVA PASS
	MOV NEXT_STATE,#S_DECRYPT
	AJMP CTR_FSM

SR_FSM_LOCKED:
	;PASSAR DE KEY_TABLE PARA SECRET_TABLE
	MOV R1,#KEY_TABLE
	MOV R0,#SECRET_TABLE
	MOV @R0,#0
SR_TRANSFER_KEY:				;Transferir a nova pass(encrypted) da key_table(80h) para a secret_table(88h)
	INC R1
	MOV N_SELECTED,@R1
	INC N_SELECTED				;ENCRYPT
	ACALL SR_INSERT_KEY
	MOV A,KEY_SIZE
	CLR C
	SUBB A,N_SELECTED
	JNZ SR_TRANSFER_KEY
	MOV NEXT_STATE,#S_LOCKED
	AJMP CTR_FSM
		
;------------------------------------------------------
STATE_BLOCKED:
	SETB OUTPUT					;tensao bloqueio
	SETB FLAG_EXAUSTED
	
	CLR FLAG_COUNTER_OPEN
	CLR FLAG_COUNTER_FAIL
	
	;INFORMAÇÃO ENVIADA PARA O TERMINAL
	SETB  TR1					
	ACALL SR_PRINT_STATE
	ACALL SR_PRINT_BLOCKED
	ACALL SR_NEW_LINE
	ACALL SR_PRINT_ATTEMPT
	ACALL SR_PRINT_ATTEMPT_NUM
	ACALL SR_NEW_LINE
	CLR TR1
	
BLOCKED_LOOP:
	
	
	
	JMP BLOCKED_LOOP
	
;----------------------------------------------------------------------------------------------------
;INTERRUPTS
;------------------------------------
INTERRUPT_K_LOAD:
	JNB K_LOAD,$
	MOV R7,#1					;PARA FICAR A 0 DPS DO DJNZ DO INTERRUPT
	SETB FLAG_K_LOAD			;QUANDO DETETA QUE O K_LOAD FOI PRESSIONADO ATIVA A FLAG 
	
	;VERIFICA SE JA PASSARAM OS 15s 
	JNB FLAG_15S,SR_GO_LOCKED
	
SR_GO_ENCRYPT:					;PASSOU DOS 15s
	SETB FLAG_TIMEOUT
	CLR EX0						;DESATIVAR A INTERRUPTION
	RETI	
	
SR_GO_LOCKED:					;AINDA NAO CHEGOU AOS 15s
	CLR FLAG_TIMEOUT
	CLR EX0						;DESATIVAR A INTERRUPTION
	RETI
;------------------------------------
ISR_TMR0:
	PUSH PSW
	PUSH ACC
	
	JB FLAG_EXAUSTED,ISR_BLOCKED
	JB FLAG_VALID,ISR_OPEN
	JB FLAG_FAIL,ISR_FAIL
	JMP ISR_TMR0_END

;-------------------
ISR_OPEN:
	JB FLAG_COUNTER_OPEN,ISR_OPEN_COUNTER	;DA PRIMEIRA VEZ
ISR_RELOAD_OPEN:
	;LIMPAR OS COUNTERS NAO UTILIZADOS
	MOV A,#0
	MOV COUNTER_ISR_FAIL,A
	MOV COUNTER_ISR_BLOCKED,A

	MOV A,#30H					;FFF830h = -2000
	MOV VAR_1,A		
	
	MOV A,#0F8H
	MOV VAR_2,A
	
	MOV A,#0FFH
	MOV VAR_3,A

ISR_OPEN_COUNTER:
	ACALL ISR_COUNTER
	
	MOV A,COUNTER_BLINK
	CJNE A,#1,ISR_CHECK_15S		
	CPL P2.7
	MOV COUNTER_BLINK,#0

ISR_CHECK_15S:
	MOV A,COUNTER_ISR_OPEN
	CJNE A,#30,ISR_OPEN_END		;COUNTER==30->60000 ciclos ISR->15s 
	
	;RESET
	CLR FLAG_15S
	CLR FLAG_COUNTER_OPEN
	
ISR_15S:
	SETB FLAG_15S
	SETB FLAG_TIMEOUT
	
ISR_OPEN_END:	
	JMP ISR_TMR0_END
;-------------------
ISR_FAIL:
	
	;LIMPAR OS COUNTERS NAO UTILIZADOS
	MOV A,#0
	MOV COUNTER_ISR_OPEN,A
	MOV COUNTER_ISR_BLOCKED,A
	MOV COUNTER_BLINK,A

	MOV A,#0C0H					;FF63C0h = -40000
	MOV VAR_1,A
					
	MOV A,#63H
	MOV VAR_2,A
	
	MOV A,#0FFH
	MOV VAR_3,A
ISR_FAIL_COUNTER:
	ACALL ISR_COUNTER
	
	;COUNTER==1...2...3...4...5
	CLR FLAG_COUNTER_FAIL
	
	JMP ISR_TMR0_END
;-------------------
ISR_BLOCKED:
	CPL BUZZER

	;LIMPAR OS COUNTERS NAO UTILIZADOS
	MOV A,#0
	MOV COUNTER_ISR_OPEN,A
	MOV COUNTER_ISR_FAIL,A
	MOV COUNTER_BLINK,A

	JB FLAG_COUNTER_BLOCKED,ISR_BLOCKED_COUNTER		;FLAG_COUNTER = 1 -> ESTÁ A CONTAR

ISR_BLOCKED_RELOAD:
	MOV A,#30H					;FFF830h = -2000
	MOV VAR_1,A		
	
	MOV A,#0F8H
	MOV VAR_2,A
	
	MOV A,#0FFH
	MOV VAR_3,A
	
ISR_BLOCKED_COUNTER:
	ACALL ISR_COUNTER
	
	MOV A,COUNTER_ISR_BLOCKED
	CJNE A,#1,ISR_TMR0_END		;1 COUNTER DE 2000 -> RATE DE "CPL" DO 'b'
	
	;RESET DO COUNTER APOS 2000
	MOV A,#0
	MOV COUNTER_ISR_BLOCKED,A
	CLR FLAG_COUNTER_BLOCKED
	
ISR_B_STATE:
	JNB FLAG_CHAR_B,ISR_B_OFF
	
ISR_B_ON:
	;APAGAR B
	MOV P2,#0FFH
	CLR FLAG_CHAR_B
	JMP ISR_TMR0_END
	
ISR_B_OFF:
	;LIGAR B
	MOV P2,#83H
	SETB FLAG_CHAR_B
	JMP ISR_TMR0_END
;-------------------
ISR_TMR0_END:
	POP ACC
	POP PSW
	;CLR ET0
	RETI

;----------------------------------------------------------------------------------------------------
;FUNCTIONS
;------------------------------------
;ISR COUNTER
;------------------------------------
ISR_COUNTER:
	CLR C

	MOV A,VAR_1
	ADD A,#1
	MOV VAR_1,A
	JNC ISR_COUNTER_END
	
	MOV A,VAR_2
	ADDC A,#0
	MOV VAR_2,A
	JNC ISR_COUNTER_END
	
	MOV A,VAR_3
	ADDC A,#0
	MOV VAR_3,A
	
	INC COUNTER_BLINK
	INC COUNTER_ISR_OPEN
	INC COUNTER_ISR_FAIL
	INC COUNTER_ISR_BLOCKED	
	
ISR_COUNTER_END:
	RET
;------------------------------------
;INSERT KEY
;------------------------------------
SR_INSERT_KEY:
	USING 0
	PUSH AR0 
	INC	@R0
	MOV A,@R0
	ADD A,R0
	MOV R0,A
	MOV A,N_SELECTED
	MOV @R0,A
	POP AR0
	MOV A,@R0
	MOV N_SELECTED,A
	RET

;------------------------------------
;COMPARE KEY
;------------------------------------
SR_COMP_KEYS:
	MOV R0,#KEY_TABLE
	MOV R1,#SECRET_TABLE
	PUSH ACC 
	USING 0
	PUSH AR2
	CLR NOT_EQUAL
	MOV A,KEY_SIZE		
	MOV R2,A			

SR_SIZE_COMPARE:
	MOV A,@R1
	XRL A,@R0
	JZ SR_COMP_ZERO
	SETB NOT_EQUAL
	JMP SR_COMP_FIM
	
SR_COMP_LOOP:
	MOV A,@R1
	DEC A						;ENCRYPT->+1
	XRL A,@R0
	JZ SR_COMP_ZERO
	SETB NOT_EQUAL
	JMP SR_COMP_FIM

SR_COMP_ZERO:
	INC R0
	INC R1
	DJNZ R2,SR_COMP_LOOP
	
SR_COMP_FIM:
	POP AR2
	POP ACC
	RET
;-------------------------------------------------------------------
;UART
;------------------------------------
SR_PRINT_STATE:
	MOV DPTR,#STATE_STRING
SR_STATE_LOOP:
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	INC R7	
	DJNZ STATE_SIZE,SR_STATE_LOOP
	MOV STATE_SIZE,#6
	MOV R7,#0
	RET
;------------------------------------
;PRINT LOCKED
SR_PRINT_LOCKED:
	MOV DPTR,#LOCKED_STRING
SR_LOCKED_LOOP:
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	INC R7
	DJNZ LOCKED_SIZE,SR_LOCKED_LOOP
	MOV LOCKED_SIZE,#6
	MOV R7,#0
	RET
;------------------------------------
;PRINT DECRYPT
SR_PRINT_DECRYPT:
	MOV DPTR,#DECRYPT_STRING
SR_DECRYPT_LOOP:
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	INC R7
	DJNZ DECRYPT_SIZE,SR_DECRYPT_LOOP
	MOV DECRYPT_SIZE,#7
	MOV R7,#0
	RET
;------------------------------------
;PRINT FAIL
SR_PRINT_FAIL:
	MOV DPTR,#FAIL_STRING
SR_FAIL_LOOP:
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	INC R7
	DJNZ FAIL_SIZE,SR_FAIL_LOOP
	MOV FAIL_SIZE,#4
	MOV R7,#0
	RET
;------------------------------------
;PRINT OPEN
SR_PRINT_OPEN:
	MOV DPTR,#OPEN_STRING
SR_OPEN_LOOP:
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	INC R7
	DJNZ OPEN_SIZE,SR_OPEN_LOOP
	MOV OPEN_SIZE,#4
	MOV R7,#0
	RET
;------------------------------------
;PRINT ENCRYPT
SR_PRINT_ENCRYPT:
	MOV DPTR,#ENCRYPT_STRING
SR_ENCRYPT_LOOP:
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	INC R7
	DJNZ ENCRYPT_SIZE,SR_ENCRYPT_LOOP
	MOV ENCRYPT_SIZE,#7
	MOV R7,#0
	RET
;------------------------------------
;PRINT BLOCKED
SR_PRINT_BLOCKED:
	MOV DPTR,#BLOCKED_STRING
SR_BLOCKED_LOOP:
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	INC R7
	DJNZ BLOCKED_SIZE,SR_BLOCKED_LOOP
	MOV BLOCKED_SIZE,#7
	MOV R7,#0
	RET
;------------------------------------
;PRINT RECOVER
SR_PRINT_RECOVER:
	MOV DPTR,#RECOVER_STRING
SR_PRINT_RECOVER_LOOP:
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	INC R7
	DJNZ RECOVER_SIZE,SR_PRINT_RECOVER_LOOP
	MOV RECOVER_SIZE,#7
	MOV R7,#0
	RET
;------------------------------------
;ATTEMPT PRINT
SR_PRINT_ATTEMPT:
	MOV DPTR,#ATTEMPT_STRING
SR_ATTEMPT_LOOP:
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	INC R7
	DJNZ ATTEMPT_SIZE,SR_ATTEMPT_LOOP
	MOV ATTEMPT_SIZE,#10
	MOV R7,#0
	RET
;------------------------------------
;ATTEMPT NUMBER PRINT
SR_PRINT_ATTEMPT_NUM:
	MOV DPTR,#ATTEMPT_NUM_ARRAY
SR_ATTEMPT_NUM_LOOP:
	MOV R7,ATTEMPT_COUNTER
	MOV A,R7
	MOVC A,@A+DPTR
	MOV SBUF0,A
	JNB TI0,$
	CLR TI0
	
SR_ATTEMPT_END:
	MOV R7,#0
	RET
;------------------------------------
;NEW LINE
SR_NEW_LINE:
	MOV R7,#10
	MOV SBUF0,R7
	JNB TI0,$
	CLR TI0
	
	MOV R7,#13
	MOV SBUF0,R7
	JNB TI0,$
	CLR TI0
	
	MOV R7,#0
	RET

;-------------------------------------------------------------------
;TIME ROUTINES
;------------------------------------------------------
;ROT t_buzzer					;rotina alarme-> onda de freq = 2KHz
;------------------------------------
SR_CONFIG_TMR0:	
	ORL CKCON,#2
	ORL TMOD,#2
	CLR TF0
	MOV TL0,#(-0FAH)			;250=0FAH
	MOV TH0,#(-0FAH)
	;SETB TR0
	RET
;-------------------------------------------------------------------
ATTEMPT_NUM_ARRAY:
	DB '12345'
ATTEMPT_STRING:
	DB 'Tentativa:'
STATE_STRING:
	DB 'State:'
LOCKED_STRING:
	DB 'Locked'
DECRYPT_STRING:
	DB 'Decrypt'
FAIL_STRING:
	DB 'Fail'
OPEN_STRING:		
	DB 'Open'
ENCRYPT_STRING:
	DB 'Encrypt'
BLOCKED_STRING:
	DB 'Blocked'
RECOVER_STRING:
	DB 'Recover'
		
SECRET_KEY:
	DB 1,0,0,0

TIME_ARRAY:
	DB 2,4,6,8,0AH

CSEG AT DIGIT_ARRAY
	DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0D8H,80H,90H,88H,80H,0C6H,0C0H,86H,8EH

END